global
  stats socket /var/run/api.sock user haproxy group haproxy mode 660 level admin expose-fd listeners
#  log stdout format raw local0 info
  log 127.0.0.1:514 local0

defaults
  mode http
  timeout client 10s
  timeout connect 5s
  timeout server 10s
  timeout http-request 10s
  log global

frontend stats
  bind *:8404
  stats enable
  stats uri /
  stats refresh 10s

frontend fe
  bind *:80
  mode http

  # Auth for moderator backend
  acl is_moderated path_beg     /api/moderators
  acl token_found req.cook(next-auth.session-token) -m found

  http-request deny content-type 'text/html' string 'Missing Nextauth session token' if is_moderated !token_found

  # get header part of the JWT
  http-request set-var(txn.alg) req.cook(next-auth.session-token),jwt_header_query('$.alg') if is_moderated

  # get payload part of the JWT
  http-request set-var(txn.exp) req.cook(next-auth.session-token),jwt_payload_query('$.exp','int') if is_moderated
  http-request set-var(txn.now) date() if is_moderated
  http-request deny content-type 'text/html' string 'JWT has expired' if is_moderated { var(txn.exp),sub(txn.now) -m int lt 0 }

  # Validate the JWT
  http-request deny content-type 'text/html' string 'Unsupported JWT signing algorithm' unless !is_moderated || { var(txn.alg) -m str HS256 }
  http-request deny content-type 'text/html' string 'Invalid JWT signature'  unless !is_moderated || { req.cook(next-auth.session-token),jwt_verify(txn.alg,"${JWT_SECRET}") -m int 1 }

  acl path_forum path_beg /api/forum
  acl path_chat path_beg /api/chat
  acl moderators_resources  path_beg         /api/moderators/resources
  acl moderators_chat       path_beg         /api/moderators/chat

  use_backend forum_microservice if path_forum
  use_backend chat_microservice if path_chat
  # use_backend moderatorsResources if moderators_resources
  # use_backend moderatorsChat if moderators_chat

  default_backend survivor_frontend


backend forum_microservice
  mode http
  server s1 host.docker.internal:8000

backend chat_microservice
  # mode http
  timeout tunnel  1h    # timeout to use with WebSocket and CONNECT
  option forwardfor

  # # Do not use httpclose (= client and server
  # # connections get closed), since it will close
  # # Websockets connections
  # no option httpclose
  # # Use "option http-server-close" to preserve
  # # client persistent connections while handling
  # # every incoming request individually, dispatching
  # # them one after another to servers, in HTTP close mode
  # option http-server-close
  server s1 host.docker.internal:8001

backend survivor_frontend
  # mode http
  server nextjs host.docker.internal:3000

# backend servers
#   balance roundrobin
#   server s1 web1:8080 check maxconn 30
#   server s2 web2:8080 check maxconn 30
#   server s3 web3:8080 check maxconn 30
